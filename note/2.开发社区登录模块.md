# 2.开发社区登录模块

## 1. 发送邮件

* 邮箱设置

  * 启用客户端SMTP服务

* Spring Email

  * 导入 jar 包

  ```Java
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-mail</artifactId>
  </dependency>
  ```

  * 邮箱参数配置

  ```Properties
  # MailProperties
  spring.mail.username=xxxxxxxxxx@qq.com
  spring.mail.password=xxxxxxxxxxxx  // 授权密码，非登录密码
  spring.mail.host=smtp.qq.com
  spring.mail.properties.mail.smtp.ssl.enable=true
  
  ```
  
  
  
  ```Properties
  `spring:
  	mail:
      	host: 10.110.xxx.xxx   #邮件服务器地址
      	port: 25               #邮件服务器端口
      	protocol: smtp         #使用的协议
      	default-encoding: UTF-8 #默认编码
      	username: user         #这个是通过邮件服务器认证的用户名和密码，不一定是邮箱，看服务器的要求
      	password: password
      	properties:            #properties中的属性都是比较灵活可配置的，其实是javax.mail.Session中对应的配置项，可以参考对应文档
        		mail.smtp.auth: true   #如果邮件服务器需要实名需要认证开启此选项
        		mail.from: 100010@qq.com   #统一设置发件人邮箱`
  ```
  
  SMTP的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地;
  SMTP服务器就是遵循SMTP协议的发送邮件服务器，不同邮件服务商均有对应的smtp服务器地址，并且这个地址会提供给大家，方便大家使用Foxmail与outlook等专业邮件管理软件时可以用的上。
  
  
  
  * 使用 JavaMailSender 发送邮件，分三步 1、发送人 2、收件人 3、邮件标题和内容
    * 编写一个MailClient工具类用来发送邮件
    * 开启logger日志
    * 注入JavaMailSender（由Spring容器管理）
    * 发送人username注入到Bean中
    * 编写一个公有的方法实现发送邮件，传入参数收件人，标题和内容
    * 构建MinmeMessage
    * 设置发件人，收件人，标题和内容 setText加上第二个参数true表示支持html文本
  * 模板引擎，使用 Thymeleaf 发送 HTML 邮件
  
    * 主动调用Template模板引擎
    * 给模板传参用context，设置其参数
    * 调用模板引擎的proces的方法，指定其方法和数据
    * 接受其生成的动态网页即字符串
  
  在src/main/java/com/nowcoder/community在新建一个util包，并创建MailClient类
  
  ```Java
  package com.nowcoder.community.util;
  
  import org.slf4j.Logger;
  import org.slf4j.LoggerFactory;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.beans.factory.annotation.Value;
  import org.springframework.mail.javamail.JavaMailSender;
  import org.springframework.mail.javamail.MimeMessageHelper;
  import org.springframework.stereotype.Component;
  
  import javax.mail.MessagingException;
  import javax.mail.internet.MimeMessage;
  
  @Component
  public class MailClient {
      
      //LoggerFactory.getLogger可以在IDE控制台打印日志，便于开发，一般加在最上面
      private static final Logger logger = LoggerFactory.getLogger(MailClient.class);
  
      @Autowired
      private JavaMailSender mailSender;
  
      @Value("${spring.mail.username}")
      private String from;
  
      public void sendMail(String to, String subject, String content) {
          try {
              MimeMessage message = mailSender.createMimeMessage();//创建一个邮件发送类
              MimeMessageHelper helper = new MimeMessageHelper(message);//创建一个邮件的模板
              helper.setFrom(from);
              helper.setTo(to);
              helper.setSubject(subject);
              helper.setText(content, true);
              mailSender.send(helper.getMimeMessage());
          } catch (MessagingException e) {
              logger.error("发送邮件失败：" + e.getMessage());
          }
      }
  }
  ```
  
  logger日志的几个方法
  logger.debug、logger.info、logger.warn、logger.error、logger.fatal 的区别：
  
  相同处：
  它们的作用都是把错误信息写到文本日志里
  
  不同的是它们表示的日志级别不同：
  日志级别由高到底是：fatal -> error -> warn -> info -> debug,低级别的会输出高级别的信息，高级别的不会输出低级别的信息，如等级设为Error的话，warn,info,debug的信息不会输出
  
  修改日志输出的级别要在log4j文件中进行配置，项目正式发布后，一般会把日志级别设置为fatal或者error
  
  
  
  在src/main/resources/templates/demo下创建testMail.html文件
  
  ```html
  <!DOCTYPE html>
  <html lang="en" xmlns:th="http://www.thymeleaf.org">
  <head>
      <meta charset="UTF-8">
      <title>html邮件</title>
  </head>
  <body>
      <p>欢迎你， <span style="color: red" th:text="${name}"></span></p>
  </body>
  </html>
  ```
  
  在src/test/java/com/nowcoder/community下新建MailTests类，进行测试
  
  ```Java
  package com.nowcoder.community;
  
  import com.nowcoder.community.util.MailClient;
  import org.junit.jupiter.api.Test;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  import org.springframework.test.context.ContextConfiguration;
  import org.thymeleaf.TemplateEngine;
  import org.thymeleaf.context.Context;
  
  @SpringBootTest
  @ContextConfiguration(classes = CommunityApplication.class)
  public class MailTests {
  
      @Autowired
      private MailClient mailClient;
  
      @Autowired
      private TemplateEngine templateEngine;
  
      @Test
      public void testTextMail() {
          mailClient.sendMail("1348656979@qq.com", "测试主题", "<h1>测试内容</h1>");
          System.out.println("发送成功");
      }
  
      @Test
      public void testHtmlMail() {
          Context context = new Context();
          context.setVariable("name", "ShayneC");
          String content = templateEngine.process("/demo/testMail", context);//引用thymeleaf h5页面
          System.out.println(content);
          mailClient.sendMail("1348656979@qq.com", "html测试", content);
      }
  }
  ```

## 2. 开发注册功能

* 访问注册页面，点击顶部区域内的链接，打开注册页面。

![image.png](.\img\4e0eb0156db90dc40d17d1cef8208cf7.png)

在src/main/java/com/nowcoder/community/controller中创建LoginController

```Java
package com.nowcoder.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class LoginController {

    @GetMapping("/register")
    public String getRegisterPage() {
        return "/site/register";
    }
}
```

* 提交注册数据，通过表单提交数据。

导入工具类,判断字符串是否为空

```
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
</dependency>
```

在src/main/java/com/nowcoder/community/util下新建CommunityUtil类

```Java
package com.nowcoder.community.util;

import org.apache.commons.lang3.StringUtils;
import org.springframework.util.DigestUtils;

import java.util.UUID;

public class CommunityUtil {

    // 生成随机字符串
    public static String generateUUID() {
        return UUID.randomUUID().toString().replaceAll("-", "");
    }

    // MD5加密//MD5只能加密不能解密
    //原串加salt拼接新串加密防破解
    // hello -> abc123def456
    // hello + 12d9k -> abc123def456gsd
    public static String md5(String key) {
        if (StringUtils.isBlank(key)) {//null,空串，空格都会判空
            return null;
        }
        return DigestUtils.md5DigestAsHex(key.getBytes());
    }
}
```

自定义域名，因为开发、上线域名不一样所以用户打开邮箱激活的链接也不一样所以给他弄成可变的

```Properties
# community
community.path.domain=http://localhost:8888
```

向UserService中注入所需要的组件

```Java
package com.nowcoder.community.service;

import com.nowcoder.community.dao.UserMapper;
import com.nowcoder.community.entity.User;
import com.nowcoder.community.util.MailClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.thymeleaf.TemplateEngine;

@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private MailClient mailClient;

    @Autowired
    private TemplateEngine templateEngine;

    @Value("${community.path.domain}")//域名
    private String domain;

    @Value("${server.servlet.context-path}")//项目名
    private String contextPath;

    public User findUserById(int id) {
        return userMapper.selectById(id);
    }
}
```

* 服务端验证账号是否已存在、邮箱是否已注册。
* 服务端发送激活邮件。

在UserSerice中添加register方法，验证注册逻辑

```java
public Map<String, Object> register(User user) {
    HashMap<String, Object> map = new HashMap<>();

    // 空值处理
    if (user == null) {
        throw new IllegalArgumentException("参数不能为空");
    }
    if (StringUtils.isBlank(user.getUsername())) {
        //判断某字符串是否为空或长度为0或由空白符(whitespace) 构成
        map.put("usernameMsg", "账号不能为空");
        return map;
    }
    if (StringUtils.isBlank(user.getPassword())) {
        map.put("passwordMsg", "密码不能为空");
        return map;
    }
    if (StringUtils.isBlank(user.getEmail())) {
        map.put("emailMsg", "邮箱不能为空");
        return map;
    }

    // 验证账号
    User u = userMapper.selectByName(user.getUsername());
    if (u != null) {
        map.put("usernameMsg", "该账户已存在");
        return map;
    }

    // 验证邮箱
    u = userMapper.selectByEmail(user.getEmail());
    if (u != null) {
        map.put("emailMsg", "该邮箱已被注册");
        return map;
    }

    // 注册用户
    user.setSalt(CommunityUtil.generateUUID().substring(0, 5));//1.随机生成盐
    user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));//2.加盐并加密
    user.setType(0);// 普通用户//'0-普通用户; 1-超级管理员; 2-版主;'
    user.setStatus(0);// 邮箱没有激活
    user.setActivationCode(CommunityUtil.generateUUID());// 设置注册激活码
    user.setHeaderUrl(String.format("http://images.nowcoder.com/head/%t.png", new Random().nextInt(1000)));
    user.setCreateTime(new Date());
    userMapper.insertUser(user);//插入后user内会回填id 具体看user-mapper.xml

    // 激活邮件
    Context context = new Context();
    //context是用来传递变量的容器,设置在context中的变量,可以在模板、Action和Jmr标签中被识别
    context.setVariable("email", user.getEmail());//设置变量
    // http://localhost:8888/community/activation/101/code
    // 激活链接：域名 + 项目名 + user.getId() + user.getActivationCode()
    String url = domain + contextPath + "/activation/" + user.getId() + "/" + user.getActivationCode();
    context.setVariable("url", url);
    String content = templateEngine.process("/mail/activation", context);
    mailClient.sendMail(user.getEmail(), "激活账号", content);

    return map;
}
```

将UserService组件注入到LoginController中并添加在register页面提交表单的方法。在注册成功后让页面跳转到operate-result.html页面

```java
package com.nowcoder.community.controller;

import com.nowcoder.community.entity.User;
import com.nowcoder.community.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private UserService userService;

    @GetMapping("/register")
    public String getRegisterPage() {
        return "/site/register";
    }

    @PostMapping("/register")
    public String register(Model model, User user) {
        Map<String, Object> map = userService.register(user);
        if (map == null || map.isEmpty()) {
            model.addAttribute("msg", "注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活!");
            model.addAttribute("target", "/index");
            return "/site/operate-result";
        } else {
            model.addAttribute("usernameMsg", map.get("usernameMsg"));
            model.addAttribute("passwordMsg", map.get("passwordMsg"));
            model.addAttribute("emailMsg", map.get("emailMsg"));
            return "/site/register";
        }
    }
}
```

激活注册账号

* 点击邮件中的链接，访问服务端的激活服务。

为了记录通过邮件激活的状态，在src/main/java/com/nowcoder/community/service中创建CommunityConstant接口

```java
package com.nowcoder.community.service;

public interface CommunityConstant {

    /**
     * 激活成功
     */
    int ACTIVATION_SUCCESS = 0;

    /**
     * 重复激活
     */
    int ACTIVATION_REPEAT = 1;

    /**
     * 激活失败
     */
    int ACTIVATION_FAILURE = 2;
}
```

并让UserService实现CommunityConstant接口，同时添加激活的方法

```java
public int activation(int userId, String code) {
    User user = userMapper.selectById(userId);
    if (user.getStatus() == 1) {
        return ACTIVATION_REPEAT;
    } else if (user.getActivationCode().equals(code)) {
        userMapper.updateStatus(userId, 1);
        return ACTIVATION_SUCCESS;
    } else {
        return ACTIVATION_FAILURE;
    }
}
```

UserService类

```java
package com.nowcoder.community.service;

import com.nowcoder.community.dao.UserMapper;
import com.nowcoder.community.entity.User;
import com.nowcoder.community.util.CommunityUtil;
import com.nowcoder.community.util.MailClient;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

@Service
public class UserService implements CommunityConstant{

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private MailClient mailClient;

    @Autowired
    private TemplateEngine templateEngine;

    @Value("${community.path.domain}")
    private String domain;

    @Value("${server.servlet.context-path}")
    private String contextPath;

    public User findUserById(int id) {
        return userMapper.selectById(id);
    }

    public Map<String, Object> register(User user) {
        HashMap<String, Object> map = new HashMap<>();

        // 空值处理
        if (user == null) {
            throw new IllegalArgumentException("参数不能为空");
        }
        if (StringUtils.isBlank(user.getUsername())) {
            map.put("usernameMsg", "账号不能为空");
            return map;
        }
        if (StringUtils.isBlank(user.getPassword())) {
            map.put("passwordMsg", "密码不能为空");
            return map;
        }
        if (StringUtils.isBlank(user.getEmail())) {
            map.put("emailMsg", "邮箱不能为空");
            return map;
        }

        // 验证账号
        User u = userMapper.selectByName(user.getUsername());
        if (u != null) {
            map.put("usernameMsg", "该账户已存在");
            return map;
        }

        // 验证邮箱
        u = userMapper.selectByEmail(user.getEmail());
        if (u != null) {
            map.put("emailMsg", "该邮箱已被注册");
            return map;
        }

        // 注册用户
        user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
        user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));
        user.setType(0);
        user.setStatus(0);
        user.setActivationCode(CommunityUtil.generateUUID());
        user.setHeaderUrl(String.format("http://images.nowcoder.com/head/%dt.png", new Random().nextInt(1000)));
        user.setCreateTime(new Date());
        userMapper.insertUser(user);

        // 激活邮件
        Context context = new Context();
        context.setVariable("email", user.getEmail());
        // http://localhost:8888/community/activation/101/code
        String url = domain + contextPath + "/activation/" + user.getId() + "/" + user.getActivationCode();
        context.setVariable("url", url);
        String content = templateEngine.process("/mail/activation", context);
        mailClient.sendMail(user.getEmail(), "激活账号", content);

        return map;
    }

    public int activation(int userId, String code) {
        User user = userMapper.selectById(userId);
        if (user.getStatus() == 1) {
            return ACTIVATION_REPEAT;
        } else if (user.getActivationCode().equals(code)) {
            userMapper.updateStatus(userId, 1);
            return ACTIVATION_SUCCESS;
        } else {
            return ACTIVATION_FAILURE;
        }
    }
}
```

在LoginController中添加激活的方法

```java
// http://localhost:8888/community/activation/101/code
@GetMapping("/activation/{userId}/{code}")
public String activation(Model model, @PathVariable("userId") int userId, @PathVariable("code") String code) {
    int result = userService.activation(userId, code);
    if (result == ACTIVATION_SUCCESS) {
        model.addAttribute("msg", "激活成功，您的账号已经可以正常使用了");
        model.addAttribute("target", "/login");
    } else if (result == ACTIVATION_REPEAT) {
        model.addAttribute("msg", "无效操作，该账号已经激活过了");
        model.addAttribute("target", "/index");
    } else {
        model.addAttribute("msg", "激活失败，您提供的激活码不正确");
        model.addAttribute("target", "/index");
    }
    return "/site/operate-result";
}
```

同时在LoginController中添加登录的方法，并修改login.html文件。

```java
@GetMapping("/login")
public String getLoginPage() {
    return "/site/login";
}
```

此时注册功能开发完成。

## 3. 会话管理

* HTTP的基本性质
  * HTTP是简单的
  * HTTP是可扩展的
  * HTTP是无状态的，有会话的
* Cookie
  * 是服务器发送到浏览器，并保存在浏览器端的一小块数据。
  * 浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。
  * **Http**是无状态的，有会话的。简单来说即便是同一个浏览器向服务器发送多个请求，多个成功的请求之间是不存在练习的，这就带来了一个问题——用户没有办法在同一个网站中进行连续的交互。
    用Cookies可以解决这个问题，是用Cookies可以创建有联系的会话。

<img src="img\image-20220304215410972.png" alt="image-20220304215410972" style="zoom:67%;" />

在HelloController中添加setCookie和getCookie的方法，测试cookie的基本使用。浏览器访问服务器时，服务器会返回一个cookie给浏览器（在response header中可以找到），浏览器会自动保存cookie，下次访问服务器时，会将其带到request header中

```java
// cookie示例
@GetMapping("/cookie/set")
@ResponseBody//返回json字符串，不加默认返回html
public String setCookie(HttpServletResponse response) {
    // 创建cookie
    Cookie cookie = new Cookie("code", CommunityUtil.generateUUID());
    // 设置cookie生效的范围
    cookie.setPath("/community/cookie");
    // 设置cookie的生存时间
    cookie.setMaxAge(60 * 5);
    // 发送cookie
    response.addCookie(cookie);
    return "set cookie";
}

@GetMapping("/cookie/get")
@ResponseBody
public String getCookie(@CookieValue("code") String code) {
    System.out.println(code);
    return "get cookie" + "->" + code;
}
```

cookie的数据是存在客户端的，存在安全性隐患，切每次访问时都会将其发送给服务器，耗流量。因此就有了session

* Session
  * 是JavaEE的标准，用于在服务端记录客户端信息。
  * 数据存放在服务端更加安全，但是也会增加服务端的内存压力。

<img src="img\image-20220304215637035.png" alt="image-20220304215637035" style="zoom:67%;" />

在在HelloController中添加setSession和getSession的方法，测试Session的基本使用。

```java
// session示例
@GetMapping("/session/set")
@ResponseBody
public String setSession(HttpSession session) {
    session.setAttribute("id", 1);
    session.setAttribute("name", "test");
    return "set session";
}

@GetMapping("/session/get")
@ResponseBody
public String getSession(HttpSession session) {
    System.out.println(session.getAttribute("id"));
    System.out.println(session.getAttribute("name"));
    return "get session";
}
```

## 4. 生成验证码

* Kaptcha

  * 导入 jar 包

  ```
  <!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha -->
  <dependency>
      <groupId>com.github.penggle</groupId>
      <artifactId>kaptcha</artifactId>
      <version>2.3.2</version>
  </dependency>
  ```

  Kaptcha核心

  ![image](.\img\8136967a1595ab3f22038cf45aee9634.png)

  * 编写 Kaptcha 配置类
  
  在src/main/java/com/nowcoder/community在新建config包，并创建KaptchaConfig
  
  ```java
  package com.nowcoder.community.config;
  
  import com.google.code.kaptcha.Producer;
  import com.google.code.kaptcha.impl.DefaultKaptcha;
  import com.google.code.kaptcha.util.Config;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  import java.util.Properties;
  
  /**
   * @Configuration 和 @Component
   * @Configuation 的本质就是 Component
   */
  @Configuration
  public class KaptchaConfig {
  
      
          Properties properties = new Properties();
          properties.setProperty("kaptcha.image.width", "100");
          properties.setProperty("kaptcha.image.height", "40");
          properties.setProperty("kaptcha.textproducer.font.size", "32");
          properties.setProperty("kaptcha.textproducer.font.color", "black");
          properties.setProperty("kaptcha.textproducer.char.string", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
          properties.setProperty("kaptcha.textproducer.char.length", "4");// 验证码文本字符长度，默认为5
          properties.setProperty("kaptcha.noise.impl", "com.google.code.kaptcha.impl.NoNoise");// 图片样式，其中NoNoise是为了避免机器人破解
  
          DefaultKaptcha kaptcha = new DefaultKaptcha();//DefaultKaptcha实现类生成验证码图片
          Config config = new Config(properties);// 配置其参数
          kaptcha.setConfig(config);// 使验证码参数生效
          return kaptcha;
      }
  }
  ```
  
  * 生成随机字符、生成图片

在LoginController中注入KaptchaConfig中的Producer组件，并添加生成验证码的Controller方法。因为每次都要重新刷新激活码，所以把地址给了个名字叫kaptcha，然后用js编写refresh_kaptcha方法，因为浏览器认为你在访问一个静态资源，相同的路径，就不刷新， 所以需要带一个随机数骗过浏览器

<script>
    function refresh_kaptcha() {
        var path = CONTEXT_PATH + "/kaptcha?p=" + Math.random(); 	    
        $("#kaptcha").attr("src", path); 	}
</script>

```java
@Autowired
private Producer kaptchaProducer;
```

```java
@GetMapping("/kaptcha")
public void getKaptcha(HttpServletResponse response, HttpSession session) {
    // 生成验证码
    String text = kaptchaProducer.createText();
    BufferedImage image = kaptchaProducer.createImage(text);

    // 将验证码存入session
    session.setAttribute("kaptcha", text);

    // 将图片输出给浏览器
    response.setContentType("image/png");
    try {
        ServletOutputStream os = response.getOutputStream();
        ImageIO.write(image, "png", os);
    } catch (IOException e) {
        logger.error("响应验证码失败" + e.getMessage());
    }
}
```

此时通过点击刷新验证码可以不断刷新验证码

<img src="img\image-20220305154429807.png" alt="image-20220305154429807" style="zoom:67%;" />

Kaptcha 是一个可高度配置的实用验证码生成工具，可自由配置的选项如：

1. 验证码的字体
2. 验证码字体的大小
3. 验证码字体的字体颜色
4. 验证码内容的范围(数字，字母，中文汉字！)
5. 验证码图片的大小，边框，边框粗细，边框颜色
6. 验证码的干扰线
7. 验证码的样式(鱼眼样式、3D、普通模糊、…)

## 5. 开发登录、退出功能

- 访问登录页面
  - 点击顶部区域内的链接，打开登录页面。
- 登录
  - 验证账号、密码、验证码。
  - 成功时，生成登录凭证，发放给客户端。
  - 失败时，跳转回登录页。
- 退出
  - 将登录凭证修改为失效状态。
  - 跳转至网站首页。

新建LoginTicket实体类

```java
package com.nowcoder.community.entity;

import java.util.Date;

public class LoginTicket {

    private int id;
    private int userId;
    private String ticket;
    private int status;
    private Date expired;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getTicket() {
        return ticket;
    }

    public void setTicket(String ticket) {
        this.ticket = ticket;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public Date getExpired() {
        return expired;
    }

    public void setExpired(Date expired) {
        this.expired = expired;
    }

    @Override
    public String toString() {
        return "LoginTicket{" +
                "id=" + id +
                ", userId=" + userId +
                ", ticket='" + ticket + '\'' +
                ", status=" + status +
                ", expired=" + expired +
                '}';
    }
}
```

并创建对应的LoginTicketMapper

```java
package com.nowcoder.community.dao;

import com.nowcoder.community.entity.LoginTicket;
import org.apache.ibatis.annotations.*;

@Mapper
public interface LoginTicketMapper {

    @Insert({
            "insert into login_ticket(user_id, ticket, status, expired) ",
            "values(#{userId}, #{ticket}, #{status}, #{expired})"
    })
    @Options(useGeneratedKeys = true, keyProperty = "id")//自增的主键id
    int insertLoginTicket(LoginTicket loginTicket);

    @Select({
            "select id, user_id, ticket, status, expired from login_ticket ",
            "where ticket=#{ticket}"
    })
    LoginTicket selectByTicket(String ticket);

    @Update({
            "update login_ticket set status = #{status} where ticket = #{ticket}"
    })
    int updateStatus(String ticket, int status);

}
```

在UserService中添加登录的业务方法

```java
public Map<String, Object> login(String username, String password, int expiredSeconds) {
    HashMap<String, Object> map = new HashMap<>();

    // 空值处理
    if (StringUtils.isBlank(username)) {
        map.put("usernameMsg", "账号不能为空");
        return map;
    }
    if (StringUtils.isBlank(password)) {
        map.put("passwordMsg", "密码不能为空");
        return map;
    }

    //验证账号
    User user = userMapper.selectByName(username);
    if (user == null) {
        map.put("usernameMsg", "该账号不存在");
        return map;
    }

    //验证状态
    if (user.getStatus() == 0) {
        map.put("usernameMsg", "该账号未激活");
        return map;
    }

    //验证密码
    password = CommunityUtil.md5(password + user.getSalt());
    if (!user.getPassword().equals(password)) {
        map.put("passwordMsg", "密码错误");
        return map;
    }

    // 此时登录成功，同时生成登录凭证
    LoginTicket loginTicket = new LoginTicket();
    loginTicket.setUserId(user.getId());
    loginTicket.setStatus(0);
    loginTicket.setTicket(CommunityUtil.generateUUID());
    loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));
    loginTicketMapper.insertLoginTicket(loginTicket);

    map.put("ticket", loginTicket.getTicket());
    return map;
}
```

在CommunityConstant中设置登录状态凭证超时时间的常量

```java
/**
 * 默认状态的登录凭证的超时时间
 */
int DEFAULT_EXPIRED_SECONDS = 3600 * 12;

/**
 * 记住我状态下的登录状态凭证超时时间
 */
int REMEMBER_EXPIRED_SECONDS = 3600 * 24 * 100;
```

在LoginController中添加登录页面表单验证的方法

```java
@PostMapping("/login")
public String login(String username, String password, String code, boolean remember, Model model, HttpSession session, HttpServletResponse response) {

    // 首先验证验证码
    String kaptcha = (String) session.getAttribute("kaptcha");
    if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) 	  {
        model.addAttribute("codeMsg", "验证码不正确");
        return "/site/login";
    }

    // 检查账号，密码
    int expiredSeconds = remember ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
    Map<String, Object> map = userService.login(username, password, expiredSeconds);
    if (map.containsKey("ticket")) {//判断是否包含指定的键名
        Cookie cookie = new Cookie("ticket", map.get("ticket").toString());
        cookie.setPath(contextPath);
        cookie.setMaxAge(expiredSeconds);
        response.addCookie(cookie);
        return "redirect:/index";//转发到对应的controller，自动调整请求，然后再输出到页面。
        //redirect:/ 就代表是回到@RequestMapping("/")请求，等于刷新页面
    } else {
        model.addAttribute("usernameMsg", map.get("usernameMsg"));
        model.addAttribute("passwordMsg", map.get("passwordMsg"));
        return "/site/login";
    }
}
```

在UserService中添加退出登录的业务方法

```java
public void logout(String ticket) {
    loginTicketMapper.updateStatus(ticket, 1);
}
```

在LoginController中添加退出登录的请求

```java
@GetMapping("/logout")
public String logout(@CookieValue("ticket") String ticket) {
    userService.logout(ticket);
    return "redirect:/login";
}
```

## 6. 显示登录信息

* 拦截器示例
  * 定义拦截器，实现HandlerInterceptor
  * 配置拦截器，为它指定拦截、排除的路径

在src/main/java/com/nowcoder/community/controller下新建一个interceptor包并创建TestInterceptor类

```java
package com.nowcoder.community.controller.interceptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class TestInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(TestInterceptor.class);

    // 在Controller之前执行在调用Controller方法或获取静态资源前被调用（静态资源包括html、js等）。
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.debug("preHandle:" + handler.toString());
        return true;
    }

    // 在Controller之后执行在调用Controller方法或获取静态资源后，但是视图还没有被渲染前调用。
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.debug("postHandle: " + handler.toString());
    }

    // 在TemplateEngine之后执行在视图渲染后进行调用，主要用来清除资源。
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.debug("afterCompletion: " + handler.toString());
    }
}
```

在src/main/java/com/nowcoder/community/config新建WebMvcConfig

```java
package com.nowcoder.community.config;

import com.nowcoder.community.controller.interceptor.TestInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private TestInterceptor testInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {/* 拦截器配置 */
        registry.addInterceptor(testInterceptor)//需要一个实现HandlerInterceptor接口的拦截器实例
                .excludePathPatterns("/**/*.css", "/**/*.css", "/**/*.png", "/**/*.jpg", "/**/*.jpeg")//用于设置不需要拦截的过滤规则
                .addPathPatterns("/register", "/login");//用于设置拦截器的过滤路径规则；addPathPatterns("/**")对所有请求都拦截
    }
}
```

![image](.\img\d7982d99def9a33799f3a0bd0e9f578f.png)

handler是指拦截的目标

WebMvcConfigurer配置类

是`Spring`内部的一种配置方式，采用`JavaBean`的形式来代替传统的`xml`配置文件形式进行针对框架个性化定制，可以自定义一些Handler，Interceptor，ViewResolver，MessageConverter。基于java-based方式的spring mvc配置，需要创建一个**配置**类并实现**`WebMvcConfigurer`** 接口；

* 拦截器应用
  * 在请求开始时查询登录用户
  * 在本次请求中持有用户数据
  * 在模板视图上显示用户数据
  * 在请求结束时清理用户数据

<img src="img\image-20220305220707840.png" alt="image-20220305220707840" style="zoom:67%;" />

![image.png](.\img\27da718cd1e634528ddcb86f866a871f.png)



在src/main/java/com/nowcoder/community/util中新建CookieUtil的工具类，用于获取cookie

```java
package com.nowcoder.community.util;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

public class CookieUtil {

    public static String getValue(HttpServletRequest request, String name) {
        if (request == null || name == null) {
            throw new IllegalArgumentException("参数为空");
        }

        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(name)) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }
}
```

在src/main/java/com/nowcoder/community/util中新建HostHolder工具类用于存储用户信息

```java
package com.nowcoder.community.util;

import com.nowcoder.community.entity.User;
import org.springframework.stereotype.Component;

/**
 * 持有用户信息，用于代替session对象
 */
@Component
public class HostHolder {

    private ThreadLocal<User> users= new ThreadLocal<>();

    public void setUser(User user) {
        users.set(user);
    }

    public User getUser() {
        return users.get();
    }

    public void clear() {
        users.remove();//清除本地内存中的本地变量
    }
}
```

[session](https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020)共享

Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。

![这里写图片描述](https://img-blog.csdn.net/20180706184138480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTU1NTczNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

用户的请求首先会到达前置网关，前置网关根据路由策略将请求分发到后端的服务器，这就会出现第一次的请求会交给服务器 1 处理，下次的请求可能会是服务B处理，如果不做 Session 共享的话，就有可能出现用户在服务2登录了，下次请求的时候到达服务 2 又要求用户重新登录



[ThreadLocal](https://www.cnblogs.com/fsmly/p/11020641.html)

多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。ThreadLocal是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。

ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题



在UserService中新建查询用户登录凭证的方法

```java
public LoginTicket findLoginTicket(String ticket) {
    return loginTicketMapper.selectByTicket(ticket);
}
```

在src/main/java/com/nowcoder/community/controller/interceptor中新建LoginTicketInterceptor拦截器

```java
package com.nowcoder.community.controller.interceptor;

import com.nowcoder.community.entity.LoginTicket;
import com.nowcoder.community.entity.User;
import com.nowcoder.community.service.UserService;
import com.nowcoder.community.util.CookieUtil;
import com.nowcoder.community.util.HostHolder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Date;

@Component
public class LoginTicketInterceptor implements HandlerInterceptor {

    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;
	//可以简单理解为controller之前通过ticket取用户登录信息
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 从cookie中获取凭证
        String ticket = CookieUtil.getValue(request, "ticket");

        if (ticket != null) {
            // 查询凭证
            LoginTicket loginTicket = userService.findLoginTicket(ticket);
            // 检查凭证是否有效
            if (loginTicket != null && loginTicket.getStatus() == 0 && loginTicket.getExpired().after(new Date())) {
                // 根据凭证查询用户
                User user = userService.findUserById(loginTicket.getUserId());
                // 在本次请求中持有用户
                hostHolder.setUser(user);
            }
        }
        return true;
    }

    @Override//在controller之后把用户信息传递给模板
    //当控制器处理完请求时，通常会将包含视图名称或视图对象以及一些模型属性的ModelAndView对象返回到DispatcherServlet。
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        User user = hostHolder.getUser();
        if (user != null && modelAndView != null) {
            modelAndView.addObject("loginUser", user);
        }
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        hostHolder.clear();
    }
}
```

在WebMvcConfig中配置loginTicketInterceptor

```java
package com.nowcoder.community.config;

import com.nowcoder.community.controller.interceptor.LoginTicketInterceptor;
import com.nowcoder.community.controller.interceptor.TestInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private TestInterceptor testInterceptor;

    @Autowired
    private LoginTicketInterceptor loginTicketInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(testInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.css", "/**/*.png", "/**/*.jpg", "/**/*.jpeg")
                .addPathPatterns("/register", "/login");

        registry.addInterceptor(loginTicketInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.css", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
    }
}
```

此时拦截器功能开发完成。

## 7. 账号设置

* 上传文件
  * 请求：必须是POST请求
  * 表单：enctype=“multipart/form-data”
  * Spring MVC：通过 MultipartFile 处理上传文件
* 开发步骤
  * 访问账号设置页面

![image.png](.\img\d88a0b70795fae1be180ec2ae1866914.png)

添加UserController，并修改setting.html

```java
package com.nowcoder.community.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
@RequestMapping("/user")
public class UserController {

    @RequestMapping(path = "/setting", method = RequestMethod.GET)
    public String getSettingPage() {
        return "/site/setting";
    }
}
```

* 上传头像
* 获取头像

在UserService中添加方法

```java
public int updateHeader(int userId, String headerUrl) {
    return userMapper.updateHeader(userId, headerUrl);
}
```

同时配置图像上传路径

```properties
community.path.upload=d:/upload
```

然后再UserController中分别添加上传图像和访问图像的请求，MultipartFile 用于接受前端传回的图片

```java
package com.nowcoder.community.controller;

import com.nowcoder.community.entity.User;
import com.nowcoder.community.service.UserService;
import com.nowcoder.community.util.CommunityUtil;
import com.nowcoder.community.util.HostHolder;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;

@Controller
@RequestMapping("/user")
public class UserController {

    private static final Logger logger = LoggerFactory.getLogger(UserController.class);

    @Value("${community.path.upload}")
    private String uploadPath;//注入文件的上传路径

    @Value("${community.path.domain}")
    private String domain;//注入域名

    @Value("${server.servlet.context-path}")
    private String contextPath;//访问路径

    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    @RequestMapping(path = "/setting", method = RequestMethod.GET)
    public String getSettingPage() {//进入账号设置
        return "/site/setting";
    }

    @RequestMapping(path = "/upload", method = RequestMethod.POST)
    public String uploadHeader(MultipartFile headerImage, Model model) {
        if (headerImage == null) {
            model.addAttribute("error", "您还没有选择图片!");
            return "/site/setting";
        }

        String filename = headerImage.getOriginalFilename();
        String suffix = filename.substring(filename.lastIndexOf("."));//获取图片后缀名
        if (StringUtils.isBlank(suffix)) {
            model.addAttribute("error", "文件的格式不正确!");
            return "/site/setting";
        }

        // 生成随机文件名
        filename = CommunityUtil.generateUUID() + suffix;

        // 如果上传路径不存在则创建文件夹
        File dir = new File(uploadPath);
        if (!dir.exists()) {
            dir.mkdir();
        }

        // 确定文件存放的路径
        File dest = new File(uploadPath + "/" + filename);
        try {
            // 存储文件
            headerImage.transferTo(dest);
        } catch (IOException e) {
            logger.error("上传文件失败：" + e.getMessage());
            throw new RuntimeException("上传文件失败，服务器发生异常！", e);
        }

        // 更新当前用户的图像的路径(web访问路径）
        // http://localhost:8888/community/user/header/xxx.png
        User user = hostHolder.getUser();
        String headerUrl = domain + contextPath + "/user/header/" + filename;
        userService.updateHeader(user.getId(), headerUrl);
        return "redirect:/index";
    }

    @RequestMapping(path = "/header/{filename}", method = RequestMethod.GET)
    public void getHeader(@PathVariable("filename") String filename, HttpServletResponse response) {
        // 服务器存放路径
        filename = uploadPath + "/" + filename;
        // 文件后缀
        String suffix = filename.substring(filename.lastIndexOf(".") + 1);
        // 响应图片
        response.setContentType("image/" + suffix);
        try(
            OutputStream os = response.getOutputStream();
            FileInputStream fis = new FileInputStream(filename);
            ) {
            byte[] buffer = new byte[1024];
            int b = 0;
            while ((b = fis.read(buffer)) != -1) {
                os.write(buffer, 0, b);
            }
        } catch (IOException e) {
            logger.error("读取图像失败" + e.getMessage());
        }
    }
}
```

在修改setting.html后即可重新启动项目进行测试。

## 8. 检查登录状态

![img](https://img-blog.csdnimg.cn/20200810170535926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU1NTM4MA==,size_16,color_FFFFFF,t_70)

![image.png](.\img\fa86dcd7e3660c8a5d5850aab4858510.png)

* 使用拦截器

  * 在方法前标注自定义注解
  * 拦截所有请求，只处理带有该注解的方法

* 自定义注解
  * 常用的元注解：
    @Target、@Retention、@Document、@Inherited

  * @Target用来表示注解作用范围，超过这个作用范围，编译的时候就会报错。声明自定义注解可以作用在什么类型上，类上方法上等

    @Target:注解的作用目标

    @Target(ElementType.TYPE)——接口、类、枚举、注解
    @Target(ElementType.FIELD)——字段、枚举的常量
    @Target(ElementType.METHOD)——方法
    @Target(ElementType.PARAMETER)——方法参数
    @Target(ElementType.CONSTRUCTOR) ——构造函数
    @Target(ElementType.LOCAL_VARIABLE)——局部变量
    @Target(ElementType.ANNOTATION_TYPE)——注解
    @Target(ElementType.PACKAGE)——包，用于记录java文件的package信息

  * @Retention是用来修饰注解的，注解的注解，声明自定义注解保留的时间

    | **取值**                | **描述**                                                     | **作用范围**      | **使用场景**                                                 |
    | ----------------------- | ------------------------------------------------------------ | ----------------- | ------------------------------------------------------------ |
    | RetentionPolicy.SOURCE  | 表示注解只保留在源文件，当java文件编译成class文件，就会消失  | 源文件            | 只是做一些检查性的操作，，比如 @Override 和 @SuppressWarnings |
    | RetentionPolicy.CLASS   | 注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期 | class文件（默认） | 要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife） |
    | RetentionPolicy.RUNTIME | 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在  | 运行时也存在      | 需要在运行时去动态获取注解信息                               |

  * @Document：声明自定义注解生成文档的时候要不要把注解也带上去

  * @Inherited：用于继承的，一个子类继承父类，父类有注解，子类要不要继承这个注解

* 如何读取注解：
  Method.getDeclaredAnnotations ()
  Method.getAnnotation (Class<T> annotationClass)

在src/main/java/com/nowcoder/community下新建一个annotation包，创建一个注解

需要解决的问题：防止直接在浏览器输入网址进入“登录信息设置”的网页。
解决方案：设置`拦截器`，拦截所有请求，且在指定的方法上进行拦截。那么可以自定义注解，让拦截器只拦截带有这个自定义注解的方法。

![image-20220426230028506](E:\xm\community-master\note\img\2860221-20220430152042463-1960206965.png)

**有区别登录拦截(想到拦截器+自定义注解)**
区分登录拦截实现流程
	1:自定义一个注解:@RequiredLogin,约定如果请求映射方法贴了这个注解,表示访问这个请求必须先登录,不贴,表示无所谓
	2:给注解赋予约定好的操作逻辑(在登录拦截器中实现约定逻辑)
		1>判断当前访问的请求映射方法是否贴有@RequiredLogin标签
		2>如果有表示当前映射方法需要登录校验
		3>如果没有表示不需要校验直接放行

```java
package com.nowcoder.community.annotation;//是否登录

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)//表示贴在方法上,只能使用在类的方法上
@Retention(RetentionPolicy.RUNTIME)//被它注解的注解保留多久,不仅保存在class文件中，jvm加载class文件后，仍然存在
/*登录校验注解 自定义注解(登录校验注解)
        约定:如果该注解贴在某个映射方法上表示该映射方法必须登录之后才可以访问
        如果某个映射方法没有该注解,表示随意*/
public @interface LoginRequired {//打了这个标记，登录时才能访问
}
```

新建LoginRequiredInterceptor拦截器，并在WebMvcConfig中进行配置，看拦截目标的类型是不是方法HandlerMethod，如果是转型成handlerMethod，获取method对象，获取注解，注解不为空`loginRequired != null`即带有这个注解（`LoginRequired.class`），即需要登录，若此时`hostHolder.getUser()==null`没登录，就要重定向到登录页面（即`项目路径+/login`），返回false，不能继续执行该方法。

```java
package com.nowcoder.community.controller.interceptor;

import com.nowcoder.community.annotation.LoginRequired;
import com.nowcoder.community.util.HostHolder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.lang.reflect.Method;

@Component
public class LoginRequiredInterceptor implements HandlerInterceptor {

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		//解决跨域问题
		//1.如果请求不是动态的,handler对象不是HandlerMethod的实例(静态页面).放行
		//2.如果请求是跨域请求(请求方法是:OPTIONS),handler对象不是HandlerMethod,当发生跨域时,
		//系统会先发送一条预请求,请求路径与真实请求一样,但是请求方式为OPTIONS它不属于handler实例,
		//不写下面这个判断,会继续后面的操作,但是由于预请求没有携带参数,
		//在后面的判断中就会被直接拦截下来,这样导致这个请求失败
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();//获取拦截方法
            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);//LoginRequired注解是否method上
            if (loginRequired != null && hostHolder.getUser() == null) {
                response.sendRedirect(request.getContextPath() + "/login");//return ”redirect“底层其实也是这个，可以通过配置文件注入路径参数，也可以从请求中直接取到路径
                return false;
            }
        }
        return true;// 如果不是映射到方法直接通过
    }
}
//handler变量是这个HandlerMethod的实例对象
//HandlerMethod 请求映射方法信息(所在类的信息,方法信息[映射路径/方法名/参数/注解/返回值]...)封装对象

1.springmvc启动时候,扫描所有controller类,解析所有映射方法,
 将每个映射方法封装一个对象HandlerMethod,该类包含所有请求映射方法信息(映射路径/方法名/参数/注解/返回值)
2.springmvc针对这些请求映射方法信息封装对象类 使用类似map的数据结构进行统一管理
  Map<String,HandlerMethod> map
	key:请求映射路径(url)
    value就是映射方法信息封装对象类
    map.put("/users/currentUser",currentUser这个映射方法对应HandlerMethod实例)
     map.put("/users/login",login这个映射方法对应HandlerMethod实例)
 3.页面发起请求时(/users/currentUser),进入拦截器之后,springmvc自动解析请求路径,
  得到url(/users/currentUser),获取url之后,进而获取/users/currentUser 路径对应的映射方法HandlerMethod实例--handler
4.调用拦截器 preHandle方法并将请求对象,响应对象 映射方法对象handler一起传入

```



最后在/setting和/upload上添加@LoginRequired注解。*只要贴了@LoginRequired这个注解,就需要将该方法拦截下来并判断是否登录过*

- 修改密码

在UserController新增如下方法

```java
@LoginRequired
@RequestMapping(path = "/updatePassword", method = RequestMethod.POST)
public String updatePassword(String password, String newPassword, String confirmPassword, Model model) {

    // 首先验证原密码
    User user = hostHolder.getUser();
    if (StringUtils.isBlank(password) || !user.getPassword().equals(CommunityUtil.md5(password + user.getSalt()))) {
        model.addAttribute("passwordMsg", "密码不正确");
        return "/site/setting";
    }

    // 修改密码
    if (newPassword.equals(confirmPassword)) {
        newPassword = CommunityUtil.md5(newPassword + user.getSalt());
        userService.updatePassword(user.getId(), newPassword);
    } else {
        model.addAttribute("confirmPasswordMsg", "两次输入的密码不一致!");
        return "/site/setting";
    }

    return "redirect:/index";

}
```

在UserService中新增如下方法

```java
public int updatePassword(int userId, String newPassword) {
    return userMapper.updatePassword(userId, newPassword);
}
```

